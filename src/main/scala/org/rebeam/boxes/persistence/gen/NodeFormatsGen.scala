package org.rebeam.boxes.persistence.gen

import java.io.File
import io.Source

object NodeFormatsGen {

  private val header = 
  s"""
    |package org.rebeam.boxes.persistence.formats
    |
    |import scala.language.implicitConversions
    |
    |import org.rebeam.boxes.persistence._
    |import org.rebeam.boxes.core._
    |import BoxTypes._
    |
    |import scalaz._
    |import Scalaz._
    |
    |/**
    | * These formats are very similar to ProductFormats, with the important difference that they expect to read/write
    | * case classes (Products) of Boxes, which we call "Nodes" for example case class Person(name: Box[String], age: Box[Int]).
    | * We refer to the Node's class as N below. Writes as a Dict with an entry for each box, containing the value of the box.
    | * The link in the DictEntry itself is used to provide an id for the Box if required, BoxTokens are not used since they
    | * are redundant. This means that a Node containing Boxes of types B1, B2 etc. will be serialised similarly to a Product
    | * containing unboxed values of B1, B2 etc. Refs are never used.
    | *
    | * There are some additional requirements/features when using these formats:
    | *  1. When reading, the formats always create the instance of N via a provided default method of type (Txn) => N,
    | *  which is expected to create a "default" case class with entirely new boxes.
    | *  2. When reading, it is acceptable for some fields to be missing - they are left as defaults. The reading process
    | *  simply creates a default N, then sets any boxes that are present in the tokens. This allows for transparent upgrading
    | *  of data from a previous version of the class with fewer fields.
    | *  3. When writing, boxes are all required NOT to be in the cache when written - that is, they are not referenced anywhere
    | *  in the token stream leading up to the moment of writing. This means that we can guarantee it is acceptable to create
    | *  a new Box when reading again.
    | *
    | *  By requiring (and enforcing) that Nodes use their own boxes and these boxes are not used in any other Nodes, we can
    | *  provide for transparent upgrading of nodes by using default values. In addition, the provided default method of type
    | *  (Txn) => N can create any required reactions when the nodes are created, providing an easy means of handling
    | *  serialisation and deserialisation of reactions.
    | *
    | *  Note this file is auto-generated by NodeFormatsGen. 
    | */
    |object NodeFormats extends NodeFormatsBase {
    |
   """.stripMargin

  /**
   * Generate a nodeFormat method of arbitrary arity
   *
   * Uses a template with the following values:
   * $fieldCount The number of fields in the product, e.g. "2"
   * $fieldTypes The parametric types of the product fields, e.g. "P1: Format, P2: Format, ..."
   * $constructorParameters The parameters to construct a new instance of the node, e.g. "Box[P1], Box[P2], ..."
   * $productNameParameters The parameters for the names of each field of the product, e.g. "name1: String, name2: String, ..."
   * $writeDictEntries The code to write all fields as dict entries, e.g. "writeDictEntry[P1](n, name1, 0, c, boxLinkStrategy)\nwriteDictEntry[P2](n, name2, 1, c, boxLinkStrategy)\n ..."
   * $useDictEntriesCases The cases to read all fields by calling useDictEntry, e.g. "case s if s == name1 => useDictEntry[P1](n, 0, c, link)\ncase s if s == name2 => useDictEntry[P2](n, 1, c, link)\n ..."
   *
   * @param n The arity of the product
   */
  private def genNodeFormat(n: Int) = {
    val indices = Range(1, n + 1)

    def format(f: (Int) => String, sep: String) = indices.map(f(_)).mkString(sep)

    val fieldCount =            "" + n

    val fieldTypes =            format(i => s"P$i: Format", ", ")

    val constructorParameters = format(i => s"Box[P$i]", ", ")

    val productNameParameters = format(i => s"name$i: String", ", ")

    val writeDictEntries =      format(i => s"_ <- writeDictEntry[P$i](n, name$i, ${i - 1}, boxLinkStrategy)", "\n        ")

    val replaceFields =         format(i => s"_ <- replaceField[P$i](n, ${i - 1}, boxId)", "\n      ")

    val modifyFields =          format(i => s"_ <- modifyField[P$i, N, A](n, ${i - 1}, boxId, readsAction)", "\n      ")

    val useDictEntriesCases =   format(i => s"case s if s == name$i => useDictEntry[P$i](n, ${i - 1}, link)", "\n              ")

    s"""
      |  def nodeFormat$fieldCount[$fieldTypes, N <: Product, A <: Action[N]](construct: ($constructorParameters) => N, default: BoxScript[N])
      |      ($productNameParameters,
      |      readsAction: Option[Reads[A]] = None, nodeName: TokenName = NoName, boxLinkStrategy: NoDuplicatesLinkStrategy = IdLinks, nodeLinkStrategy: LinkStrategy = IdLinks) : Format[N] = new Format[N] {
      |
      |    def writeEntriesAndClose(n: N): BoxWriterScript[Unit] = {
      |      import BoxWriterDeltaF._
      |      for {
      |        $writeDictEntries
      |        _ <- put(CloseDict)
      |      } yield ()
      |    }
      |
      |    def readEntries(n: N): BoxReaderScript[Unit] = {
      |      import BoxReaderDeltaF._
      |      for {
      |        t <- peek
      |        _ <- if (t == CloseDict) {
      |          nothing
      |        } else {
      |          pull flatMap {
      |            case DictEntry(fieldName, link) => fieldName match {
      |              $useDictEntriesCases
      |              case x => throw new IncorrectTokenException("Unknown field name in Node dict " + x)
      |            }
      |            case x: Token => throw new IncorrectTokenException("Expected DictEntry in a Node Dict, got " + x)
      |          } flatMap {_ => readEntries(n)}
      |        }
      |      } yield ()
      |    }
      |
      |    def readEntriesAndClose = {
      |      import BoxReaderDeltaF._
      |      for {
      |        n <- embedBoxScript(default)  //Note default is a BoxScript, so we need to embed it
      |        _ <- readEntries(n)
      |        _ <- pullExpected(CloseDict)
      |      } yield n
      |    }
      |
      |    def write(n: N) = writeNode(n, nodeName, nodeLinkStrategy, writeEntriesAndClose)
      |    def read = readNode(readEntriesAndClose)
      |
      |    def replace(n: N, boxId: Long) = for {
      |      $replaceFields
      |    } yield ()
      |
      |    def modify(n: N, boxId: Long) = for {
      |      $modifyFields
      |    } yield ()
      |
      |  }
    """.stripMargin
  }

  def firstLine(f: File): Option[String] = {
    val src = Source.fromFile(f)
    val line = src.getLines.take(1).toList
    src.close
    line.headOption
  }
  
  def printToFile(f: java.io.File)(op: java.io.PrintWriter => Unit) {
    val p = new java.io.PrintWriter(f)
    try { op(p) } finally { p.close() }
  }
  
  def main(args: Array[String]) {
    val persistenceDir = new File(System.getProperty("user.dir") + "/src/main/scala/org/rebeam/boxes/persistence")
    val outputFile = new File(persistenceDir, "/formats/NodeFormats.scala")

    val className = this.getClass.toString
    
    //Check that the file is generated by us...
    val currentFirstLine = firstLine(outputFile)
    val correctFirstLine = "//!!!Generated by " + className
    
    
    currentFirstLine match {
      case Some(s) if s.contains(correctFirstLine) => 
        printToFile(outputFile) { op =>
          op.println(correctFirstLine)
          op.println(header)
          for (i <- Range(1, 23)) op.println(genNodeFormat(i))
          op.println("}")
        }
        
      case _ => 
        println("Mismatch :( Expected:")
        println(correctFirstLine)
        println("Got:")
        println(currentFirstLine)
    }
    
  }

}
